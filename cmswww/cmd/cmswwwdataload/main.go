package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/decred/contractor-mgmt/cmswww/api/v1"
	cliconfig "github.com/decred/contractor-mgmt/cmswww/cmd/cmswwwcli/config"
	wwwconfig "github.com/decred/contractor-mgmt/cmswww/sharedconfig"
	"github.com/decred/dcrd/chaincfg"
	"github.com/decred/dcrd/dcrutil"

	"github.com/decred/contractor-mgmt/cmswww/cmd/cmswwwdataload/client"
	"github.com/decred/contractor-mgmt/cmswww/cmd/cmswwwdataload/config"
)

var (
	cfg          *config.Config
	c            *client.Client
	politeiadCmd *exec.Cmd
	cmswwwCmd    *exec.Cmd

	cmswwwLogFile *os.File
	pdLogFile     *os.File

	numInvoices int
)

func createLogFile(path string) (*os.File, error) {
	os.Remove(path)
	return os.OpenFile(path, os.O_CREATE|os.O_WRONLY, 0644)
}

func createInvoiceFile(month, year uint16, numRecords int) (string, error) {
	fmt.Printf("Creating invoice file\n")
	date := time.Date(int(year), time.Month(month), 1, 0, 0, 0, 0, time.UTC)
	filepath := path.Join(cfg.DataDir, date.Format("2006-01.csv"))
	file, err := os.OpenFile(filepath, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return "", err
	}

	file.WriteString(fmt.Sprintf("# %v\n", date.Format("2006-01")))
	file.WriteString("# This file was generated by the dataload utility.\n")
	for i := 1; i <= numRecords; i++ {
		file.WriteString(fmt.Sprintf("Development,Task %v,,,%v,%v\n", i, 20, 20*i))
	}
	return filepath, file.Sync()
}

func waitForStartOfDay(out io.Reader) {
	buf := bufio.NewScanner(out)
	for buf.Scan() {
		text := buf.Text()
		if strings.Contains(text, "Start of day") {
			return
		}
	}
}

func startCmswww() error {
	fmt.Printf("Starting cmswww\n")
	cmswwwCmd = c.CreateCmswwwCmd()

	stdout, _ := cmswwwCmd.StdoutPipe()
	if err := cmswwwCmd.Start(); err != nil {
		cmswwwCmd = nil
		return err
	}

	if cmswwwLogFile == nil {
		var err error
		cmswwwLogFile, err = createLogFile(cfg.CmswwwLogFile)
		if err != nil {
			return err
		}
	}

	reader := io.TeeReader(stdout, cmswwwLogFile)
	waitForStartOfDay(reader)
	go io.Copy(cmswwwLogFile, stdout)

	// Get the version for the csrf
	return c.Version()
}

func startPoliteiad() error {
	fmt.Printf("Starting politeiad\n")
	politeiadCmd = c.CreatePoliteiadCmd()

	stdout, _ := politeiadCmd.StdoutPipe()
	if err := politeiadCmd.Start(); err != nil {
		politeiadCmd = nil
		return err
	}

	if pdLogFile == nil {
		var err error
		pdLogFile, err = createLogFile(cfg.PoliteiadLogFile)
		if err != nil {
			return err
		}
	}

	reader := io.TeeReader(stdout, pdLogFile)
	waitForStartOfDay(reader)
	go io.Copy(pdLogFile, stdout)

	return nil
}

func setNewIdentity(email, password string) error {
	if _, err := c.Login(email, password); err != nil {
		return err
	}

	token, err := c.NewIdentity()
	if err != nil {
		return err
	}

	if err = c.VerifyIdentity(token); err != nil {
		return err
	}

	return c.Logout()
}

func submitInvoice(email, password, filepath string) (string, error) {
	if _, err := c.Login(email, password); err != nil {
		return "", err
	}

	token, err := c.SubmitInvoice(filepath)
	if err != nil {
		return "", err
	}

	numInvoices++
	return token, c.Logout()
}

func editInvoice(email, password, token, filepath string) error {
	if _, err := c.Login(email, password); err != nil {
		return err
	}

	err := c.EditInvoice(token, filepath)
	if err != nil {
		return err
	}

	return c.Logout()
}

func approveInvoice(email, password, token string) error {
	if _, err := c.Login(email, password); err != nil {
		return err
	}

	err := c.ApproveInvoice(token)
	if err != nil {
		return err
	}

	return c.Logout()
}

func rejectInvoice(email, password, token, reason string) error {
	if _, err := c.Login(email, password); err != nil {
		return err
	}

	err := c.RejectInvoice(token, reason)
	if err != nil {
		return err
	}

	return c.Logout()
}

func payApprovedInvoices(email, password string, month, year uint16, usdDCRRate float64) error {
	if _, err := c.Login(email, password); err != nil {
		return err
	}

	_, err := c.PayInvoices(month, year, usdDCRRate)
	if err != nil {
		return err
	}

	return c.Logout()
}

func testInventory(email, password string) error {
	if _, err := c.Login(email, password); err != nil {
		return err
	}

	invoices, err := c.GetAllInvoices()
	if err != nil {
		return err
	}

	if len(invoices) != numInvoices {
		return fmt.Errorf("Expected %v invoices, got %v", numInvoices, len(invoices))
	}

	if err := c.Logout(); err != nil {
		return err
	}

	// Test inventory on startup as well.
	stopCmswww()
	if err = startCmswww(); err != nil {
		return err
	}

	if _, err := c.Login(email, password); err != nil {
		return err
	}

	invoices, err = c.GetAllInvoices()
	if err != nil {
		return err
	}

	if len(invoices) != numInvoices {
		return fmt.Errorf("Expected %v invoices, got %v", numInvoices, len(invoices))
	}

	return c.Logout()
}

func testPasswordResetAndChange(email, password string) error {
	newPassword := generateRandomString(16)
	if err := c.ResetPassword(email, newPassword); err != nil {
		return err
	}

	if _, err := c.Login(email, newPassword); err != nil {
		return err
	}

	if err := c.ChangePassword(newPassword, password); err != nil {
		return err
	}

	return c.Logout()
}

func testEditUser(email, password string) error {
	lr, err := c.Login(email, password)
	if err != nil {
		return err
	}

	udr, err := c.UserDetails(lr.UserID)
	if err != nil {
		return err
	}

	newName := generateRandomString(16)
	newLocation := generateRandomString(16)
	newExtendedPublicKey := generateRandomString(16)

	if err := c.EditUser(newName, newLocation, newExtendedPublicKey); err != nil {
		return err
	}

	udr2, err := c.UserDetails(lr.UserID)
	if err != nil {
		return err
	}

	if newName != udr2.User.Name {
		return fmt.Errorf("User's name was not modified")
	}
	if newLocation != udr2.User.Location {
		return fmt.Errorf("User's location was not modified")
	}
	if newExtendedPublicKey != udr2.User.ExtendedPublicKey {
		return fmt.Errorf("User's extended public key was not modified")
	}

	if err := c.EditUser(udr.User.Name, udr.User.Location, udr.User.ExtendedPublicKey); err != nil {
		return err
	}

	udr3, err := c.UserDetails(lr.UserID)
	if err != nil {
		return err
	}

	if udr.User.Name != udr3.User.Name {
		return fmt.Errorf("User's name was not changed back")
	}
	if udr.User.Location != udr3.User.Location {
		return fmt.Errorf("User's location was not changed back")
	}
	if udr.User.ExtendedPublicKey != udr3.User.ExtendedPublicKey {
		return fmt.Errorf("User's extended public key was not changed back")
	}

	return c.Logout()
}

func testMultiplePayments(email, pass, invoiceToken string, month, year uint16) error {
	if _, err := c.Login(email, pass); err != nil {
		return err
	}

	// Generate a new total cost payment for the invoice.
	pir, err := c.PayInvoices(month, year, 10.0)
	if err != nil {
		return err
	}

	var invoicePayment *v1.InvoicePayment
	for _, ip := range pir.Invoices {
		if ip.Token == invoiceToken {
			invoicePayment = &ip
			break
		}
	}

	if invoicePayment == nil {
		return fmt.Errorf("payment for invoice with token %v not found",
			invoiceToken)
	}

	// Update the invoice as paid with a fake transaction.
	amount, err := dcrutil.NewAmount(invoicePayment.TotalCostDCR)
	if err != nil {
		return err
	}

	_, err = c.UpdateInvoicePayment(invoiceToken,
		invoicePayment.PaymentAddress, uint64(amount),
		"9ab1f8413bb895f46088e317d42a950e929ab8649961cc4a9311cba5c7bff73a")
	if err != nil {
		return err
	}

	// Create a one-off additional payment for this invoice.
	reply, err := c.PayInvoice(invoiceToken, 20, 10.0)
	if err != nil {
		return err
	}
	addlInvoicePayment := reply.Invoice

	// Restart the server to verify that the additional payment is correctly
	// stored and retrieved from politeiad.
	stopCmswww()
	if err = startCmswww(); err != nil {
		return err
	}
	if _, err := c.Login(email, pass); err != nil {
		return err
	}

	// Update the one-off additional invoice payment as paid with a fake
	// transaction.
	amount, err = dcrutil.NewAmount(addlInvoicePayment.TotalCostDCR)
	if err != nil {
		return err
	}

	_, err = c.UpdateInvoicePayment(invoiceToken,
		addlInvoicePayment.PaymentAddress, uint64(amount),
		"9ab1f8413bb895f46088e317d42a950e929ab8649961cc4a9311cba5c7bff73a")
	return err
}

func createContractorUser(
	adminEmail,
	adminPass,
	contractorEmail,
	contractorUser,
	contractorPass,
	contractorName,
	contractorLocation,
	contractorExtendedPublicKey string,
) error {
	if _, err := c.Login(adminEmail, adminPass); err != nil {
		return err
	}

	_, err := c.InviteUser(contractorEmail)
	if err != nil {
		return err
	}

	token, err := c.ResendInvite(contractorEmail)
	if err != nil {
		return err
	}

	if err = c.Logout(); err != nil {
		return err
	}

	return c.RegisterUser(
		contractorEmail,
		contractorUser,
		contractorPass,
		contractorName,
		contractorLocation,
		contractorExtendedPublicKey,
		token)
}

func deleteExistingData() error {
	fmt.Printf("Deleting existing data\n")

	// politeiad data dir
	politeiadDataDir := filepath.Join(dcrutil.AppDataDir("politeiad", false), "data")
	if err := os.RemoveAll(politeiadDataDir); err != nil {
		return err
	}

	// cmswww data dir
	testnetDataDir := filepath.Join(wwwconfig.DefaultDataDir,
		chaincfg.TestNet3Params.Name)
	os.RemoveAll(filepath.Join(testnetDataDir, "sessions"))
	os.Remove(filepath.Join(testnetDataDir, "csrf.key"))

	// cmswww db
	if err := c.DeleteAllData(); err != nil {
		return err
	}

	// cmswww cli dir
	os.RemoveAll(cliconfig.HomeDir)
	return nil
}

func stopPoliteiad() {
	if politeiadCmd != nil {
		fmt.Printf("Stopping politeiad\n")
		pdLogFile.Sync()
		politeiadCmd.Process.Kill()
		politeiadCmd = nil
	}
}

func stopCmswww() {
	if cmswwwCmd != nil {
		fmt.Printf("Stopping cmswww\n")
		cmswwwLogFile.Sync()
		cmswwwCmd.Process.Kill()
		cmswwwCmd = nil
	}
}

func stopServers() {
	stopPoliteiad()
	stopCmswww()
}

func _main() error {
	// Load configuration and parse command line.  This function also
	// initializes logging and configures it accordingly.
	var err error
	cfg, err = config.Load()
	if err != nil {
		return fmt.Errorf("Could not load configuration file: %v", err)
	}

	c = client.NewClient(cfg)

	if cfg.DeleteData {
		if err = deleteExistingData(); err != nil {
			return err
		}
	}

	err = c.CreateAdminUser(cfg.AdminEmail, cfg.AdminUser, cfg.AdminPass)
	if err != nil {
		return err
	}

	if err = startPoliteiad(); err != nil {
		return err
	}

	if err = startCmswww(); err != nil {
		return err
	}

	if err = setNewIdentity(cfg.AdminEmail, cfg.AdminPass); err != nil {
		return err
	}

	err = createContractorUser(
		cfg.AdminEmail,
		cfg.AdminPass,
		cfg.ContractorEmail,
		cfg.ContractorUser,
		cfg.ContractorPass,
		cfg.ContractorName,
		cfg.ContractorLocation,
		cfg.ContractorExtendedPublicKey,
	)
	if err != nil {
		return err
	}

	if err = setNewIdentity(cfg.ContractorEmail, cfg.ContractorPass); err != nil {
		return err
	}

	nonReviewedInvoiceFilepath, err := createInvoiceFile(8, 2018, 5)
	if err != nil {
		return err
	}
	_, err = submitInvoice(cfg.ContractorEmail, cfg.ContractorPass,
		nonReviewedInvoiceFilepath)
	if err != nil {
		return err
	}

	invoiceToRejectFilepath, err := createInvoiceFile(9, 2018, 5)
	if err != nil {
		return err
	}
	invoiceToRejectToken, err := submitInvoice(cfg.ContractorEmail, cfg.ContractorPass,
		invoiceToRejectFilepath)
	if err != nil {
		return err
	}

	err = rejectInvoice(cfg.AdminEmail, cfg.AdminPass, invoiceToRejectToken,
		"Reason for rejection")
	if err != nil {
		return err
	}

	invoiceToRejectAndReviseFilepath, err := createInvoiceFile(10, 2018, 5)
	if err != nil {
		return err
	}
	invoiceToRejectAndReviseToken, err := submitInvoice(cfg.ContractorEmail,
		cfg.ContractorPass, invoiceToRejectAndReviseFilepath)
	if err != nil {
		return err
	}

	err = rejectInvoice(cfg.AdminEmail, cfg.AdminPass,
		invoiceToRejectAndReviseToken, "Reason for rejection")
	if err != nil {
		return err
	}

	err = editInvoice(cfg.ContractorEmail, cfg.ContractorPass,
		invoiceToRejectAndReviseToken, invoiceToRejectAndReviseFilepath)
	if err != nil {
		return err
	}

	invoiceToApproveFilepath, err := createInvoiceFile(11, 2018, 5)
	if err != nil {
		return err
	}
	invoiceToApproveToken, err := submitInvoice(cfg.ContractorEmail,
		cfg.ContractorPass, invoiceToApproveFilepath)
	if err != nil {
		return err
	}

	err = approveInvoice(cfg.AdminEmail, cfg.AdminPass, invoiceToApproveToken)
	if err != nil {
		return err
	}

	invoiceToPayFilepath, err := createInvoiceFile(12, 2018, 5)
	if err != nil {
		return err
	}
	invoiceToPayToken, err := submitInvoice(cfg.ContractorEmail,
		cfg.ContractorPass, invoiceToPayFilepath)
	if err != nil {
		return err
	}

	err = approveInvoice(cfg.AdminEmail, cfg.AdminPass, invoiceToPayToken)
	if err != nil {
		return err
	}

	err = payApprovedInvoices(cfg.AdminEmail, cfg.AdminPass, 12, 2018, 20.0)
	if err != nil {
		return err
	}

	if cfg.IncludeTests {
		err = testInventory(cfg.AdminEmail, cfg.AdminPass)
		if err != nil {
			return err
		}

		err = testPasswordResetAndChange(cfg.AdminEmail, cfg.AdminPass)
		if err != nil {
			return err
		}

		err = testEditUser(cfg.ContractorEmail, cfg.ContractorPass)
		if err != nil {
			return err
		}

		return testMultiplePayments(cfg.AdminEmail, cfg.AdminPass,
			invoiceToPayToken, 12, 2018)
	}

	fmt.Printf("Load data complete\n")
	return nil
}

func main() {
	err := _main()
	if err != nil {
		fmt.Fprintf(os.Stderr, "main error: %v\n", err)
	}
	stopServers()
	if err != nil {
		os.Exit(1)
	}
}
